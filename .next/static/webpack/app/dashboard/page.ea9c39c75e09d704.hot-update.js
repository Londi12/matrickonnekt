"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./app/utils/userProgress.ts":
/*!***********************************!*\
  !*** ./app/utils/userProgress.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addAchievement: () => (/* binding */ addAchievement),\n/* harmony export */   addActivity: () => (/* binding */ addActivity),\n/* harmony export */   getUserProgress: () => (/* binding */ getUserProgress),\n/* harmony export */   initializeUserProgress: () => (/* binding */ initializeUserProgress),\n/* harmony export */   markLessonCompleted: () => (/* binding */ markLessonCompleted),\n/* harmony export */   markTopicCompleted: () => (/* binding */ markTopicCompleted),\n/* harmony export */   recordQuizCompletion: () => (/* binding */ recordQuizCompletion),\n/* harmony export */   updateStreak: () => (/* binding */ updateStreak),\n/* harmony export */   updateStudyTime: () => (/* binding */ updateStudyTime)\n/* harmony export */ });\n/* harmony import */ var _firebase_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../firebase/config */ \"(app-pages-browser)/./app/firebase/config.ts\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n\n\n// Initialize user progress when they first sign up\nasync function initializeUserProgress(userId) {\n    const userProgressRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase_config__WEBPACK_IMPORTED_MODULE_0__.db, 'userProgress', userId);\n    const initialProgress = {\n        userId,\n        subjects: {},\n        totalStudyTime: 0,\n        currentStreak: 0,\n        longestStreak: 0,\n        lastStudyDate: new Date(),\n        recentActivity: [] // Initialize as empty array\n    };\n    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(userProgressRef, initialProgress);\n    return initialProgress;\n}\n// Get user progress\nasync function getUserProgress(userId) {\n    const userProgressRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase_config__WEBPACK_IMPORTED_MODULE_0__.db, 'userProgress', userId);\n    const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(userProgressRef);\n    if (docSnap.exists()) {\n        const data = docSnap.data();\n        // Convert timestamp strings back to Date objects\n        if (data.recentActivity && Array.isArray(data.recentActivity)) {\n            data.recentActivity = data.recentActivity.map((activity)=>{\n                // Handle empty or invalid activity objects\n                if (!activity || typeof activity !== 'object' || Object.keys(activity).length === 0) {\n                    return {\n                        id: Date.now().toString(),\n                        type: 'study',\n                        subject: 'unknown',\n                        topic: 'unknown',\n                        timestamp: new Date().toISOString()\n                    };\n                }\n                try {\n                    // Ensure all required fields are present\n                    const timestamp = activity.timestamp ? new Date(activity.timestamp) : new Date();\n                    if (isNaN(timestamp.getTime())) {\n                        console.warn('Invalid timestamp in activity:', activity);\n                        return {\n                            id: activity.id || Date.now().toString(),\n                            type: activity.type || 'study',\n                            subject: activity.subject || 'unknown',\n                            topic: activity.topic || 'unknown',\n                            timestamp: new Date().toISOString()\n                        };\n                    }\n                    return {\n                        id: activity.id || Date.now().toString(),\n                        type: activity.type || 'study',\n                        subject: activity.subject || 'unknown',\n                        topic: activity.topic || 'unknown',\n                        timestamp: timestamp.toISOString()\n                    };\n                } catch (error) {\n                    console.warn('Error converting timestamp:', error);\n                    return {\n                        id: activity.id || Date.now().toString(),\n                        type: activity.type || 'study',\n                        subject: activity.subject || 'unknown',\n                        topic: activity.topic || 'unknown',\n                        timestamp: new Date().toISOString()\n                    };\n                }\n            });\n        } else {\n            // Initialize recentActivity if it doesn't exist\n            data.recentActivity = [];\n        }\n        return data;\n    }\n    return null;\n}\n// Mark lesson as completed\nasync function markLessonCompleted(userId, subjectId, topicId, lessonId) {\n    const userProgressRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase_config__WEBPACK_IMPORTED_MODULE_0__.db, 'userProgress', userId);\n    const progress = await getUserProgress(userId);\n    if (progress) {\n        // Initialize subjects if it doesn't exist\n        const subjects = progress.subjects || {};\n        const subject = subjects[subjectId] || {\n            progress: 0,\n            completedTopics: [],\n            completedLessons: {},\n            lastStudied: new Date()\n        };\n        // Update completed lessons\n        const topicLessons = subject.completedLessons[topicId] || [];\n        if (!topicLessons.includes(lessonId)) {\n            topicLessons.push(lessonId);\n        }\n        // Calculate topic progress\n        const topicProgress = calculateTopicProgress(topicLessons);\n        // Update subject progress\n        const updatedSubjects = {\n            ...subjects,\n            [subjectId]: {\n                ...subject,\n                completedLessons: {\n                    ...subject.completedLessons,\n                    [topicId]: topicLessons\n                },\n                progress: calculateSubjectProgress(subject, topicId, topicProgress),\n                lastStudied: new Date()\n            }\n        };\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userProgressRef, {\n            subjects: updatedSubjects\n        });\n        // Add activity\n        const activity = {\n            id: Date.now().toString(),\n            type: 'study',\n            subject: subjectId,\n            topic: topicId,\n            lessonId,\n            timestamp: new Date()\n        };\n        await addActivity(userId, activity);\n    }\n}\n// Calculate topic progress based on completed lessons\nfunction calculateTopicProgress(completedLessons) {\n    // Assuming each topic has a fixed number of lessons (e.g., 5)\n    const totalLessons = 5; // This should be dynamic based on actual lesson count\n    return completedLessons.length / totalLessons * 100;\n}\n// Calculate subject progress based on topic progress\nfunction calculateSubjectProgress(subject, updatedTopicId, updatedTopicProgress) {\n    const topics = Object.keys(subject.completedLessons);\n    const totalTopics = topics.length;\n    if (totalTopics === 0) return 0;\n    let totalProgress = 0;\n    topics.forEach((topicId)=>{\n        const topicLessons = subject.completedLessons[topicId] || [];\n        const topicProgress = calculateTopicProgress(topicLessons);\n        totalProgress += topicProgress;\n    });\n    return totalProgress / totalTopics;\n}\n// Update study time\nasync function updateStudyTime(userId, minutesStudied) {\n    const userProgressRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase_config__WEBPACK_IMPORTED_MODULE_0__.db, 'userProgress', userId);\n    const progress = await getUserProgress(userId);\n    if (progress) {\n        const totalStudyTime = progress.totalStudyTime + minutesStudied;\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userProgressRef, {\n            totalStudyTime\n        });\n    }\n}\n// Mark topic as completed\nasync function markTopicCompleted(userId, subjectId, topicId) {\n    const userProgressRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase_config__WEBPACK_IMPORTED_MODULE_0__.db, 'userProgress', userId);\n    const progress = await getUserProgress(userId);\n    if (progress) {\n        const subject = progress.subjects[subjectId] || {\n            progress: 0,\n            completedTopics: [],\n            lastStudied: new Date()\n        };\n        if (!subject.completedTopics.includes(topicId)) {\n            const updatedSubjects = {\n                ...progress.subjects,\n                [subjectId]: {\n                    ...subject,\n                    completedTopics: [\n                        ...subject.completedTopics,\n                        topicId\n                    ],\n                    lastStudied: new Date()\n                }\n            };\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userProgressRef, {\n                subjects: updatedSubjects\n            });\n            // Add activity\n            const activity = {\n                id: Date.now().toString(),\n                type: 'study',\n                subject: subjectId,\n                topic: topicId,\n                timestamp: new Date()\n            };\n            await addActivity(userId, activity);\n        }\n    }\n}\n// Update streak\nasync function updateStreak(userId) {\n    const userProgressRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase_config__WEBPACK_IMPORTED_MODULE_0__.db, 'userProgress', userId);\n    const progress = await getUserProgress(userId);\n    if (progress) {\n        const lastStudyDate = new Date(progress.lastStudyDate);\n        const today = new Date();\n        const diffDays = Math.floor((today.getTime() - lastStudyDate.getTime()) / (1000 * 60 * 60 * 24));\n        let currentStreak = progress.currentStreak;\n        if (diffDays === 1) {\n            // Consecutive day\n            currentStreak += 1;\n            const longestStreak = Math.max(currentStreak, progress.longestStreak);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userProgressRef, {\n                currentStreak,\n                longestStreak,\n                lastStudyDate: today\n            });\n        } else if (diffDays > 1) {\n            // Streak broken\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userProgressRef, {\n                currentStreak: 1,\n                lastStudyDate: today\n            });\n        }\n        // Check for streak achievements\n        if (currentStreak === 7) {\n            await addAchievement(userId, {\n                id: 'week-streak',\n                title: 'Week Warrior',\n                description: 'Studied for 7 days in a row!',\n                unlockedAt: new Date(),\n                icon: 'ðŸ”¥'\n            });\n        }\n    }\n}\n// Add achievement\nasync function addAchievement(userId, achievement) {\n    const userProgressRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase_config__WEBPACK_IMPORTED_MODULE_0__.db, 'userProgress', userId);\n    const progress = await getUserProgress(userId);\n    if (progress) {\n        const hasAchievement = progress.recentActivity.some((activity)=>activity.topic === achievement.title);\n        if (!hasAchievement) {\n            const activity = {\n                id: Date.now().toString(),\n                type: 'study',\n                subject: 'achievements',\n                topic: achievement.title,\n                timestamp: new Date()\n            };\n            await addActivity(userId, activity);\n        }\n    }\n}\n// Add activity\nasync function addActivity(userId, activity) {\n    const userProgressRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase_config__WEBPACK_IMPORTED_MODULE_0__.db, 'userProgress', userId);\n    const progress = await getUserProgress(userId);\n    if (progress) {\n        // Ensure all required fields are present and timestamp is in ISO format\n        const activityWithTimestamp = {\n            id: activity.id || Date.now().toString(),\n            type: activity.type || 'study',\n            subject: activity.subject || 'unknown',\n            topic: activity.topic || 'unknown',\n            timestamp: activity.timestamp instanceof Date ? activity.timestamp.toISOString() : new Date().toISOString()\n        };\n        // Ensure recentActivity exists and is an array\n        const currentActivities = Array.isArray(progress.recentActivity) ? progress.recentActivity : [];\n        const updatedActivities = [\n            activityWithTimestamp,\n            ...currentActivities\n        ].slice(0, 10); // Keep only last 10 activities\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userProgressRef, {\n            recentActivity: updatedActivities\n        });\n    }\n}\n// Record quiz completion\nasync function recordQuizCompletion(userId, subject, score) {\n    const activity = {\n        id: Date.now().toString(),\n        type: 'study',\n        subject,\n        topic: 'quiz',\n        timestamp: new Date(),\n        score\n    };\n    await addActivity(userId, activity);\n    // Check for achievements\n    if (score >= 90) {\n        await addAchievement(userId, {\n            id: 'high-scorer',\n            title: 'High Scorer',\n            description: 'Scored 90% or higher on a quiz!',\n            unlockedAt: new Date(),\n            icon: 'ðŸŽ¯'\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC91dGlscy91c2VyUHJvZ3Jlc3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDNkM7QUFXckYsbURBQW1EO0FBQzVDLGVBQWVLLHVCQUF1QkMsTUFBYztJQUN6RCxNQUFNQyxrQkFBa0JOLHVEQUFHQSxDQUFDRCxnREFBRUEsRUFBRSxnQkFBZ0JNO0lBRWhELE1BQU1FLGtCQUFnQztRQUNwQ0Y7UUFDQUcsVUFBVSxDQUFDO1FBQ1hDLGdCQUFnQjtRQUNoQkMsZUFBZTtRQUNmQyxlQUFlO1FBQ2ZDLGVBQWUsSUFBSUM7UUFDbkJDLGdCQUFnQixFQUFFLENBQUMsNEJBQTRCO0lBQ2pEO0lBRUEsTUFBTVosMERBQU1BLENBQUNJLGlCQUFpQkM7SUFDOUIsT0FBT0E7QUFDVDtBQUVBLG9CQUFvQjtBQUNiLGVBQWVRLGdCQUFnQlYsTUFBYztJQUNsRCxNQUFNQyxrQkFBa0JOLHVEQUFHQSxDQUFDRCxnREFBRUEsRUFBRSxnQkFBZ0JNO0lBQ2hELE1BQU1XLFVBQVUsTUFBTWYsMERBQU1BLENBQUNLO0lBRTdCLElBQUlVLFFBQVFDLE1BQU0sSUFBSTtRQUNwQixNQUFNQyxPQUFPRixRQUFRRSxJQUFJO1FBQ3pCLGlEQUFpRDtRQUNqRCxJQUFJQSxLQUFLSixjQUFjLElBQUlLLE1BQU1DLE9BQU8sQ0FBQ0YsS0FBS0osY0FBYyxHQUFHO1lBQzdESSxLQUFLSixjQUFjLEdBQUdJLEtBQUtKLGNBQWMsQ0FBQ08sR0FBRyxDQUFDLENBQUNDO2dCQUM3QywyQ0FBMkM7Z0JBQzNDLElBQUksQ0FBQ0EsWUFBWSxPQUFPQSxhQUFhLFlBQVlDLE9BQU9DLElBQUksQ0FBQ0YsVUFBVUcsTUFBTSxLQUFLLEdBQUc7b0JBQ25GLE9BQU87d0JBQ0xDLElBQUliLEtBQUtjLEdBQUcsR0FBR0MsUUFBUTt3QkFDdkJDLE1BQU07d0JBQ05DLFNBQVM7d0JBQ1RDLE9BQU87d0JBQ1BDLFdBQVcsSUFBSW5CLE9BQU9vQixXQUFX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SThELFNBQVMsSUFBSTtRQUNmLE1BQU1iLGVBQWVsRSxRQUFRO1lBQzNCcUIsSUFBSTtZQUNKOEMsT0FBTztZQUNQQyxhQUFhO1lBQ2JDLFlBQVksSUFBSTdEO1lBQ2hCOEQsTUFBTTtRQUNSO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxMb25kaVxcRGVza3RvcFxccHJvamVjdHNcXG1hdHJpY2tvbm5la3RcXGFwcFxcdXRpbHNcXHVzZXJQcm9ncmVzcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkYiB9IGZyb20gJy4uL2ZpcmViYXNlL2NvbmZpZyc7XHJcbmltcG9ydCB7IGRvYywgZ2V0RG9jLCBzZXREb2MsIHVwZGF0ZURvYywgc2VydmVyVGltZXN0YW1wIH0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcclxuaW1wb3J0IHsgVXNlclByb2dyZXNzLCBBY3Rpdml0eSwgU3R1ZHlBY3Rpdml0eSB9IGZyb20gJy4uL3R5cGVzL3VzZXInO1xyXG5cclxuaW50ZXJmYWNlIEFjaGlldmVtZW50IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICB1bmxvY2tlZEF0OiBEYXRlO1xyXG4gIGljb246IHN0cmluZztcclxufVxyXG5cclxuLy8gSW5pdGlhbGl6ZSB1c2VyIHByb2dyZXNzIHdoZW4gdGhleSBmaXJzdCBzaWduIHVwXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplVXNlclByb2dyZXNzKHVzZXJJZDogc3RyaW5nKSB7XHJcbiAgY29uc3QgdXNlclByb2dyZXNzUmVmID0gZG9jKGRiLCAndXNlclByb2dyZXNzJywgdXNlcklkKTtcclxuICBcclxuICBjb25zdCBpbml0aWFsUHJvZ3Jlc3M6IFVzZXJQcm9ncmVzcyA9IHtcclxuICAgIHVzZXJJZCxcclxuICAgIHN1YmplY3RzOiB7fSxcclxuICAgIHRvdGFsU3R1ZHlUaW1lOiAwLFxyXG4gICAgY3VycmVudFN0cmVhazogMCxcclxuICAgIGxvbmdlc3RTdHJlYWs6IDAsXHJcbiAgICBsYXN0U3R1ZHlEYXRlOiBuZXcgRGF0ZSgpLFxyXG4gICAgcmVjZW50QWN0aXZpdHk6IFtdIC8vIEluaXRpYWxpemUgYXMgZW1wdHkgYXJyYXlcclxuICB9O1xyXG5cclxuICBhd2FpdCBzZXREb2ModXNlclByb2dyZXNzUmVmLCBpbml0aWFsUHJvZ3Jlc3MpO1xyXG4gIHJldHVybiBpbml0aWFsUHJvZ3Jlc3M7XHJcbn1cclxuXHJcbi8vIEdldCB1c2VyIHByb2dyZXNzXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyUHJvZ3Jlc3ModXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJQcm9ncmVzcyB8IG51bGw+IHtcclxuICBjb25zdCB1c2VyUHJvZ3Jlc3NSZWYgPSBkb2MoZGIsICd1c2VyUHJvZ3Jlc3MnLCB1c2VySWQpO1xyXG4gIGNvbnN0IGRvY1NuYXAgPSBhd2FpdCBnZXREb2ModXNlclByb2dyZXNzUmVmKTtcclxuICBcclxuICBpZiAoZG9jU25hcC5leGlzdHMoKSkge1xyXG4gICAgY29uc3QgZGF0YSA9IGRvY1NuYXAuZGF0YSgpO1xyXG4gICAgLy8gQ29udmVydCB0aW1lc3RhbXAgc3RyaW5ncyBiYWNrIHRvIERhdGUgb2JqZWN0c1xyXG4gICAgaWYgKGRhdGEucmVjZW50QWN0aXZpdHkgJiYgQXJyYXkuaXNBcnJheShkYXRhLnJlY2VudEFjdGl2aXR5KSkge1xyXG4gICAgICBkYXRhLnJlY2VudEFjdGl2aXR5ID0gZGF0YS5yZWNlbnRBY3Rpdml0eS5tYXAoKGFjdGl2aXR5OiBhbnkpID0+IHtcclxuICAgICAgICAvLyBIYW5kbGUgZW1wdHkgb3IgaW52YWxpZCBhY3Rpdml0eSBvYmplY3RzXHJcbiAgICAgICAgaWYgKCFhY3Rpdml0eSB8fCB0eXBlb2YgYWN0aXZpdHkgIT09ICdvYmplY3QnIHx8IE9iamVjdC5rZXlzKGFjdGl2aXR5KS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHR5cGU6ICdzdHVkeScsXHJcbiAgICAgICAgICAgIHN1YmplY3Q6ICd1bmtub3duJyxcclxuICAgICAgICAgICAgdG9waWM6ICd1bmtub3duJyxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gRW5zdXJlIGFsbCByZXF1aXJlZCBmaWVsZHMgYXJlIHByZXNlbnRcclxuICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IGFjdGl2aXR5LnRpbWVzdGFtcCBcclxuICAgICAgICAgICAgPyBuZXcgRGF0ZShhY3Rpdml0eS50aW1lc3RhbXApXHJcbiAgICAgICAgICAgIDogbmV3IERhdGUoKTtcclxuXHJcbiAgICAgICAgICBpZiAoaXNOYU4odGltZXN0YW1wLmdldFRpbWUoKSkpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIHRpbWVzdGFtcCBpbiBhY3Rpdml0eTonLCBhY3Rpdml0eSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgaWQ6IGFjdGl2aXR5LmlkIHx8IERhdGUubm93KCkudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICB0eXBlOiBhY3Rpdml0eS50eXBlIHx8ICdzdHVkeScsXHJcbiAgICAgICAgICAgICAgc3ViamVjdDogYWN0aXZpdHkuc3ViamVjdCB8fCAndW5rbm93bicsXHJcbiAgICAgICAgICAgICAgdG9waWM6IGFjdGl2aXR5LnRvcGljIHx8ICd1bmtub3duJyxcclxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBhY3Rpdml0eS5pZCB8fCBEYXRlLm5vdygpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHR5cGU6IGFjdGl2aXR5LnR5cGUgfHwgJ3N0dWR5JyxcclxuICAgICAgICAgICAgc3ViamVjdDogYWN0aXZpdHkuc3ViamVjdCB8fCAndW5rbm93bicsXHJcbiAgICAgICAgICAgIHRvcGljOiBhY3Rpdml0eS50b3BpYyB8fCAndW5rbm93bicsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgY29udmVydGluZyB0aW1lc3RhbXA6JywgZXJyb3IpO1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IGFjdGl2aXR5LmlkIHx8IERhdGUubm93KCkudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgdHlwZTogYWN0aXZpdHkudHlwZSB8fCAnc3R1ZHknLFxyXG4gICAgICAgICAgICBzdWJqZWN0OiBhY3Rpdml0eS5zdWJqZWN0IHx8ICd1bmtub3duJyxcclxuICAgICAgICAgICAgdG9waWM6IGFjdGl2aXR5LnRvcGljIHx8ICd1bmtub3duJyxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEluaXRpYWxpemUgcmVjZW50QWN0aXZpdHkgaWYgaXQgZG9lc24ndCBleGlzdFxyXG4gICAgICBkYXRhLnJlY2VudEFjdGl2aXR5ID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YSBhcyBVc2VyUHJvZ3Jlc3M7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vLyBNYXJrIGxlc3NvbiBhcyBjb21wbGV0ZWRcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1hcmtMZXNzb25Db21wbGV0ZWQoXHJcbiAgdXNlcklkOiBzdHJpbmcsXHJcbiAgc3ViamVjdElkOiBzdHJpbmcsXHJcbiAgdG9waWNJZDogc3RyaW5nLFxyXG4gIGxlc3NvbklkOiBudW1iZXJcclxuKSB7XHJcbiAgY29uc3QgdXNlclByb2dyZXNzUmVmID0gZG9jKGRiLCAndXNlclByb2dyZXNzJywgdXNlcklkKTtcclxuICBjb25zdCBwcm9ncmVzcyA9IGF3YWl0IGdldFVzZXJQcm9ncmVzcyh1c2VySWQpO1xyXG5cclxuICBpZiAocHJvZ3Jlc3MpIHtcclxuICAgIC8vIEluaXRpYWxpemUgc3ViamVjdHMgaWYgaXQgZG9lc24ndCBleGlzdFxyXG4gICAgY29uc3Qgc3ViamVjdHMgPSBwcm9ncmVzcy5zdWJqZWN0cyB8fCB7fTtcclxuICAgIFxyXG4gICAgY29uc3Qgc3ViamVjdCA9IHN1YmplY3RzW3N1YmplY3RJZF0gfHwge1xyXG4gICAgICBwcm9ncmVzczogMCxcclxuICAgICAgY29tcGxldGVkVG9waWNzOiBbXSxcclxuICAgICAgY29tcGxldGVkTGVzc29uczoge30sXHJcbiAgICAgIGxhc3RTdHVkaWVkOiBuZXcgRGF0ZSgpXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFVwZGF0ZSBjb21wbGV0ZWQgbGVzc29uc1xyXG4gICAgY29uc3QgdG9waWNMZXNzb25zID0gc3ViamVjdC5jb21wbGV0ZWRMZXNzb25zW3RvcGljSWRdIHx8IFtdO1xyXG4gICAgaWYgKCF0b3BpY0xlc3NvbnMuaW5jbHVkZXMobGVzc29uSWQpKSB7XHJcbiAgICAgIHRvcGljTGVzc29ucy5wdXNoKGxlc3NvbklkKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdG9waWMgcHJvZ3Jlc3NcclxuICAgIGNvbnN0IHRvcGljUHJvZ3Jlc3MgPSBjYWxjdWxhdGVUb3BpY1Byb2dyZXNzKHRvcGljTGVzc29ucyk7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBzdWJqZWN0IHByb2dyZXNzXHJcbiAgICBjb25zdCB1cGRhdGVkU3ViamVjdHMgPSB7XHJcbiAgICAgIC4uLnN1YmplY3RzLFxyXG4gICAgICBbc3ViamVjdElkXToge1xyXG4gICAgICAgIC4uLnN1YmplY3QsXHJcbiAgICAgICAgY29tcGxldGVkTGVzc29uczoge1xyXG4gICAgICAgICAgLi4uc3ViamVjdC5jb21wbGV0ZWRMZXNzb25zLFxyXG4gICAgICAgICAgW3RvcGljSWRdOiB0b3BpY0xlc3NvbnNcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb2dyZXNzOiBjYWxjdWxhdGVTdWJqZWN0UHJvZ3Jlc3Moc3ViamVjdCwgdG9waWNJZCwgdG9waWNQcm9ncmVzcyksXHJcbiAgICAgICAgbGFzdFN0dWRpZWQ6IG5ldyBEYXRlKClcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBhd2FpdCB1cGRhdGVEb2ModXNlclByb2dyZXNzUmVmLCB7IHN1YmplY3RzOiB1cGRhdGVkU3ViamVjdHMgfSk7XHJcblxyXG4gICAgLy8gQWRkIGFjdGl2aXR5XHJcbiAgICBjb25zdCBhY3Rpdml0eTogU3R1ZHlBY3Rpdml0eSA9IHtcclxuICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcclxuICAgICAgdHlwZTogJ3N0dWR5JyxcclxuICAgICAgc3ViamVjdDogc3ViamVjdElkLFxyXG4gICAgICB0b3BpYzogdG9waWNJZCxcclxuICAgICAgbGVzc29uSWQsXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKVxyXG4gICAgfTtcclxuXHJcbiAgICBhd2FpdCBhZGRBY3Rpdml0eSh1c2VySWQsIGFjdGl2aXR5KTtcclxuICB9XHJcbn1cclxuXHJcbi8vIENhbGN1bGF0ZSB0b3BpYyBwcm9ncmVzcyBiYXNlZCBvbiBjb21wbGV0ZWQgbGVzc29uc1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVUb3BpY1Byb2dyZXNzKGNvbXBsZXRlZExlc3NvbnM6IG51bWJlcltdKTogbnVtYmVyIHtcclxuICAvLyBBc3N1bWluZyBlYWNoIHRvcGljIGhhcyBhIGZpeGVkIG51bWJlciBvZiBsZXNzb25zIChlLmcuLCA1KVxyXG4gIGNvbnN0IHRvdGFsTGVzc29ucyA9IDU7IC8vIFRoaXMgc2hvdWxkIGJlIGR5bmFtaWMgYmFzZWQgb24gYWN0dWFsIGxlc3NvbiBjb3VudFxyXG4gIHJldHVybiAoY29tcGxldGVkTGVzc29ucy5sZW5ndGggLyB0b3RhbExlc3NvbnMpICogMTAwO1xyXG59XHJcblxyXG4vLyBDYWxjdWxhdGUgc3ViamVjdCBwcm9ncmVzcyBiYXNlZCBvbiB0b3BpYyBwcm9ncmVzc1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVTdWJqZWN0UHJvZ3Jlc3MoXHJcbiAgc3ViamVjdDogYW55LFxyXG4gIHVwZGF0ZWRUb3BpY0lkOiBzdHJpbmcsXHJcbiAgdXBkYXRlZFRvcGljUHJvZ3Jlc3M6IG51bWJlclxyXG4pOiBudW1iZXIge1xyXG4gIGNvbnN0IHRvcGljcyA9IE9iamVjdC5rZXlzKHN1YmplY3QuY29tcGxldGVkTGVzc29ucyk7XHJcbiAgY29uc3QgdG90YWxUb3BpY3MgPSB0b3BpY3MubGVuZ3RoO1xyXG4gIFxyXG4gIGlmICh0b3RhbFRvcGljcyA9PT0gMCkgcmV0dXJuIDA7XHJcbiAgXHJcbiAgbGV0IHRvdGFsUHJvZ3Jlc3MgPSAwO1xyXG4gIHRvcGljcy5mb3JFYWNoKHRvcGljSWQgPT4ge1xyXG4gICAgY29uc3QgdG9waWNMZXNzb25zID0gc3ViamVjdC5jb21wbGV0ZWRMZXNzb25zW3RvcGljSWRdIHx8IFtdO1xyXG4gICAgY29uc3QgdG9waWNQcm9ncmVzcyA9IGNhbGN1bGF0ZVRvcGljUHJvZ3Jlc3ModG9waWNMZXNzb25zKTtcclxuICAgIHRvdGFsUHJvZ3Jlc3MgKz0gdG9waWNQcm9ncmVzcztcclxuICB9KTtcclxuICBcclxuICByZXR1cm4gdG90YWxQcm9ncmVzcyAvIHRvdGFsVG9waWNzO1xyXG59XHJcblxyXG4vLyBVcGRhdGUgc3R1ZHkgdGltZVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlU3R1ZHlUaW1lKHVzZXJJZDogc3RyaW5nLCBtaW51dGVzU3R1ZGllZDogbnVtYmVyKSB7XHJcbiAgY29uc3QgdXNlclByb2dyZXNzUmVmID0gZG9jKGRiLCAndXNlclByb2dyZXNzJywgdXNlcklkKTtcclxuICBjb25zdCBwcm9ncmVzcyA9IGF3YWl0IGdldFVzZXJQcm9ncmVzcyh1c2VySWQpO1xyXG5cclxuICBpZiAocHJvZ3Jlc3MpIHtcclxuICAgIGNvbnN0IHRvdGFsU3R1ZHlUaW1lID0gcHJvZ3Jlc3MudG90YWxTdHVkeVRpbWUgKyBtaW51dGVzU3R1ZGllZDtcclxuICAgIGF3YWl0IHVwZGF0ZURvYyh1c2VyUHJvZ3Jlc3NSZWYsIHsgdG90YWxTdHVkeVRpbWUgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBNYXJrIHRvcGljIGFzIGNvbXBsZXRlZFxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWFya1RvcGljQ29tcGxldGVkKHVzZXJJZDogc3RyaW5nLCBzdWJqZWN0SWQ6IHN0cmluZywgdG9waWNJZDogc3RyaW5nKSB7XHJcbiAgY29uc3QgdXNlclByb2dyZXNzUmVmID0gZG9jKGRiLCAndXNlclByb2dyZXNzJywgdXNlcklkKTtcclxuICBjb25zdCBwcm9ncmVzcyA9IGF3YWl0IGdldFVzZXJQcm9ncmVzcyh1c2VySWQpO1xyXG5cclxuICBpZiAocHJvZ3Jlc3MpIHtcclxuICAgIGNvbnN0IHN1YmplY3QgPSBwcm9ncmVzcy5zdWJqZWN0c1tzdWJqZWN0SWRdIHx8IHtcclxuICAgICAgcHJvZ3Jlc3M6IDAsXHJcbiAgICAgIGNvbXBsZXRlZFRvcGljczogW10sXHJcbiAgICAgIGxhc3RTdHVkaWVkOiBuZXcgRGF0ZSgpXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICghc3ViamVjdC5jb21wbGV0ZWRUb3BpY3MuaW5jbHVkZXModG9waWNJZCkpIHtcclxuICAgICAgY29uc3QgdXBkYXRlZFN1YmplY3RzID0ge1xyXG4gICAgICAgIC4uLnByb2dyZXNzLnN1YmplY3RzLFxyXG4gICAgICAgIFtzdWJqZWN0SWRdOiB7XHJcbiAgICAgICAgICAuLi5zdWJqZWN0LFxyXG4gICAgICAgICAgY29tcGxldGVkVG9waWNzOiBbLi4uc3ViamVjdC5jb21wbGV0ZWRUb3BpY3MsIHRvcGljSWRdLFxyXG4gICAgICAgICAgbGFzdFN0dWRpZWQ6IG5ldyBEYXRlKClcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBhd2FpdCB1cGRhdGVEb2ModXNlclByb2dyZXNzUmVmLCB7IHN1YmplY3RzOiB1cGRhdGVkU3ViamVjdHMgfSk7XHJcblxyXG4gICAgICAvLyBBZGQgYWN0aXZpdHlcclxuICAgICAgY29uc3QgYWN0aXZpdHk6IFN0dWR5QWN0aXZpdHkgPSB7XHJcbiAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcclxuICAgICAgICB0eXBlOiAnc3R1ZHknLFxyXG4gICAgICAgIHN1YmplY3Q6IHN1YmplY3RJZCxcclxuICAgICAgICB0b3BpYzogdG9waWNJZCxcclxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGF3YWl0IGFkZEFjdGl2aXR5KHVzZXJJZCwgYWN0aXZpdHkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gVXBkYXRlIHN0cmVha1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlU3RyZWFrKHVzZXJJZDogc3RyaW5nKSB7XHJcbiAgY29uc3QgdXNlclByb2dyZXNzUmVmID0gZG9jKGRiLCAndXNlclByb2dyZXNzJywgdXNlcklkKTtcclxuICBjb25zdCBwcm9ncmVzcyA9IGF3YWl0IGdldFVzZXJQcm9ncmVzcyh1c2VySWQpO1xyXG5cclxuICBpZiAocHJvZ3Jlc3MpIHtcclxuICAgIGNvbnN0IGxhc3RTdHVkeURhdGUgPSBuZXcgRGF0ZShwcm9ncmVzcy5sYXN0U3R1ZHlEYXRlKTtcclxuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcclxuICAgIGNvbnN0IGRpZmZEYXlzID0gTWF0aC5mbG9vcigodG9kYXkuZ2V0VGltZSgpIC0gbGFzdFN0dWR5RGF0ZS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKTtcclxuXHJcbiAgICBsZXQgY3VycmVudFN0cmVhayA9IHByb2dyZXNzLmN1cnJlbnRTdHJlYWs7XHJcbiAgICBpZiAoZGlmZkRheXMgPT09IDEpIHtcclxuICAgICAgLy8gQ29uc2VjdXRpdmUgZGF5XHJcbiAgICAgIGN1cnJlbnRTdHJlYWsgKz0gMTtcclxuICAgICAgY29uc3QgbG9uZ2VzdFN0cmVhayA9IE1hdGgubWF4KGN1cnJlbnRTdHJlYWssIHByb2dyZXNzLmxvbmdlc3RTdHJlYWspO1xyXG4gICAgICBhd2FpdCB1cGRhdGVEb2ModXNlclByb2dyZXNzUmVmLCB7XHJcbiAgICAgICAgY3VycmVudFN0cmVhayxcclxuICAgICAgICBsb25nZXN0U3RyZWFrLFxyXG4gICAgICAgIGxhc3RTdHVkeURhdGU6IHRvZGF5XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmIChkaWZmRGF5cyA+IDEpIHtcclxuICAgICAgLy8gU3RyZWFrIGJyb2tlblxyXG4gICAgICBhd2FpdCB1cGRhdGVEb2ModXNlclByb2dyZXNzUmVmLCB7XHJcbiAgICAgICAgY3VycmVudFN0cmVhazogMSxcclxuICAgICAgICBsYXN0U3R1ZHlEYXRlOiB0b2RheVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBmb3Igc3RyZWFrIGFjaGlldmVtZW50c1xyXG4gICAgaWYgKGN1cnJlbnRTdHJlYWsgPT09IDcpIHtcclxuICAgICAgYXdhaXQgYWRkQWNoaWV2ZW1lbnQodXNlcklkLCB7XHJcbiAgICAgICAgaWQ6ICd3ZWVrLXN0cmVhaycsXHJcbiAgICAgICAgdGl0bGU6ICdXZWVrIFdhcnJpb3InLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU3R1ZGllZCBmb3IgNyBkYXlzIGluIGEgcm93IScsXHJcbiAgICAgICAgdW5sb2NrZWRBdDogbmV3IERhdGUoKSxcclxuICAgICAgICBpY29uOiAn8J+UpSdcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBBZGQgYWNoaWV2ZW1lbnRcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZEFjaGlldmVtZW50KHVzZXJJZDogc3RyaW5nLCBhY2hpZXZlbWVudDogQWNoaWV2ZW1lbnQpIHtcclxuICBjb25zdCB1c2VyUHJvZ3Jlc3NSZWYgPSBkb2MoZGIsICd1c2VyUHJvZ3Jlc3MnLCB1c2VySWQpO1xyXG4gIGNvbnN0IHByb2dyZXNzID0gYXdhaXQgZ2V0VXNlclByb2dyZXNzKHVzZXJJZCk7XHJcblxyXG4gIGlmIChwcm9ncmVzcykge1xyXG4gICAgY29uc3QgaGFzQWNoaWV2ZW1lbnQgPSBwcm9ncmVzcy5yZWNlbnRBY3Rpdml0eS5zb21lKFxyXG4gICAgICBhY3Rpdml0eSA9PiBhY3Rpdml0eS50b3BpYyA9PT0gYWNoaWV2ZW1lbnQudGl0bGVcclxuICAgICk7XHJcbiAgICBcclxuICAgIGlmICghaGFzQWNoaWV2ZW1lbnQpIHtcclxuICAgICAgY29uc3QgYWN0aXZpdHk6IFN0dWR5QWN0aXZpdHkgPSB7XHJcbiAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcclxuICAgICAgICB0eXBlOiAnc3R1ZHknLFxyXG4gICAgICAgIHN1YmplY3Q6ICdhY2hpZXZlbWVudHMnLFxyXG4gICAgICAgIHRvcGljOiBhY2hpZXZlbWVudC50aXRsZSxcclxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGF3YWl0IGFkZEFjdGl2aXR5KHVzZXJJZCwgYWN0aXZpdHkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gQWRkIGFjdGl2aXR5XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRBY3Rpdml0eSh1c2VySWQ6IHN0cmluZywgYWN0aXZpdHk6IFN0dWR5QWN0aXZpdHkpIHtcclxuICBjb25zdCB1c2VyUHJvZ3Jlc3NSZWYgPSBkb2MoZGIsICd1c2VyUHJvZ3Jlc3MnLCB1c2VySWQpO1xyXG4gIGNvbnN0IHByb2dyZXNzID0gYXdhaXQgZ2V0VXNlclByb2dyZXNzKHVzZXJJZCk7XHJcblxyXG4gIGlmIChwcm9ncmVzcykge1xyXG4gICAgLy8gRW5zdXJlIGFsbCByZXF1aXJlZCBmaWVsZHMgYXJlIHByZXNlbnQgYW5kIHRpbWVzdGFtcCBpcyBpbiBJU08gZm9ybWF0XHJcbiAgICBjb25zdCBhY3Rpdml0eVdpdGhUaW1lc3RhbXAgPSB7XHJcbiAgICAgIGlkOiBhY3Rpdml0eS5pZCB8fCBEYXRlLm5vdygpLnRvU3RyaW5nKCksXHJcbiAgICAgIHR5cGU6IGFjdGl2aXR5LnR5cGUgfHwgJ3N0dWR5JyxcclxuICAgICAgc3ViamVjdDogYWN0aXZpdHkuc3ViamVjdCB8fCAndW5rbm93bicsXHJcbiAgICAgIHRvcGljOiBhY3Rpdml0eS50b3BpYyB8fCAndW5rbm93bicsXHJcbiAgICAgIHRpbWVzdGFtcDogYWN0aXZpdHkudGltZXN0YW1wIGluc3RhbmNlb2YgRGF0ZSBcclxuICAgICAgICA/IGFjdGl2aXR5LnRpbWVzdGFtcC50b0lTT1N0cmluZygpXHJcbiAgICAgICAgOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIH07XHJcblxyXG4gICAgLy8gRW5zdXJlIHJlY2VudEFjdGl2aXR5IGV4aXN0cyBhbmQgaXMgYW4gYXJyYXlcclxuICAgIGNvbnN0IGN1cnJlbnRBY3Rpdml0aWVzID0gQXJyYXkuaXNBcnJheShwcm9ncmVzcy5yZWNlbnRBY3Rpdml0eSkgXHJcbiAgICAgID8gcHJvZ3Jlc3MucmVjZW50QWN0aXZpdHkgXHJcbiAgICAgIDogW107XHJcblxyXG4gICAgY29uc3QgdXBkYXRlZEFjdGl2aXRpZXMgPSBbYWN0aXZpdHlXaXRoVGltZXN0YW1wLCAuLi5jdXJyZW50QWN0aXZpdGllc10uc2xpY2UoMCwgMTApOyAvLyBLZWVwIG9ubHkgbGFzdCAxMCBhY3Rpdml0aWVzXHJcbiAgICBcclxuICAgIGF3YWl0IHVwZGF0ZURvYyh1c2VyUHJvZ3Jlc3NSZWYsIHtcclxuICAgICAgcmVjZW50QWN0aXZpdHk6IHVwZGF0ZWRBY3Rpdml0aWVzXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFJlY29yZCBxdWl6IGNvbXBsZXRpb25cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlY29yZFF1aXpDb21wbGV0aW9uKHVzZXJJZDogc3RyaW5nLCBzdWJqZWN0OiBzdHJpbmcsIHNjb3JlOiBudW1iZXIpIHtcclxuICBjb25zdCBhY3Rpdml0eTogU3R1ZHlBY3Rpdml0eSA9IHtcclxuICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXHJcbiAgICB0eXBlOiAnc3R1ZHknLFxyXG4gICAgc3ViamVjdCxcclxuICAgIHRvcGljOiAncXVpeicsXHJcbiAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICBzY29yZVxyXG4gIH07XHJcblxyXG4gIGF3YWl0IGFkZEFjdGl2aXR5KHVzZXJJZCwgYWN0aXZpdHkpO1xyXG5cclxuICAvLyBDaGVjayBmb3IgYWNoaWV2ZW1lbnRzXHJcbiAgaWYgKHNjb3JlID49IDkwKSB7XHJcbiAgICBhd2FpdCBhZGRBY2hpZXZlbWVudCh1c2VySWQsIHtcclxuICAgICAgaWQ6ICdoaWdoLXNjb3JlcicsXHJcbiAgICAgIHRpdGxlOiAnSGlnaCBTY29yZXInLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ1Njb3JlZCA5MCUgb3IgaGlnaGVyIG9uIGEgcXVpeiEnLFxyXG4gICAgICB1bmxvY2tlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICBpY29uOiAn8J+OrydcclxuICAgIH0pO1xyXG4gIH1cclxufSAiXSwibmFtZXMiOlsiZGIiLCJkb2MiLCJnZXREb2MiLCJzZXREb2MiLCJ1cGRhdGVEb2MiLCJpbml0aWFsaXplVXNlclByb2dyZXNzIiwidXNlcklkIiwidXNlclByb2dyZXNzUmVmIiwiaW5pdGlhbFByb2dyZXNzIiwic3ViamVjdHMiLCJ0b3RhbFN0dWR5VGltZSIsImN1cnJlbnRTdHJlYWsiLCJsb25nZXN0U3RyZWFrIiwibGFzdFN0dWR5RGF0ZSIsIkRhdGUiLCJyZWNlbnRBY3Rpdml0eSIsImdldFVzZXJQcm9ncmVzcyIsImRvY1NuYXAiLCJleGlzdHMiLCJkYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiYWN0aXZpdHkiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiaWQiLCJub3ciLCJ0b1N0cmluZyIsInR5cGUiLCJzdWJqZWN0IiwidG9waWMiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsImlzTmFOIiwiZ2V0VGltZSIsImNvbnNvbGUiLCJ3YXJuIiwiZXJyb3IiLCJtYXJrTGVzc29uQ29tcGxldGVkIiwic3ViamVjdElkIiwidG9waWNJZCIsImxlc3NvbklkIiwicHJvZ3Jlc3MiLCJjb21wbGV0ZWRUb3BpY3MiLCJjb21wbGV0ZWRMZXNzb25zIiwibGFzdFN0dWRpZWQiLCJ0b3BpY0xlc3NvbnMiLCJpbmNsdWRlcyIsInB1c2giLCJ0b3BpY1Byb2dyZXNzIiwiY2FsY3VsYXRlVG9waWNQcm9ncmVzcyIsInVwZGF0ZWRTdWJqZWN0cyIsImNhbGN1bGF0ZVN1YmplY3RQcm9ncmVzcyIsImFkZEFjdGl2aXR5IiwidG90YWxMZXNzb25zIiwidXBkYXRlZFRvcGljSWQiLCJ1cGRhdGVkVG9waWNQcm9ncmVzcyIsInRvcGljcyIsInRvdGFsVG9waWNzIiwidG90YWxQcm9ncmVzcyIsImZvckVhY2giLCJ1cGRhdGVTdHVkeVRpbWUiLCJtaW51dGVzU3R1ZGllZCIsIm1hcmtUb3BpY0NvbXBsZXRlZCIsInVwZGF0ZVN0cmVhayIsInRvZGF5IiwiZGlmZkRheXMiLCJNYXRoIiwiZmxvb3IiLCJtYXgiLCJhZGRBY2hpZXZlbWVudCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJ1bmxvY2tlZEF0IiwiaWNvbiIsImFjaGlldmVtZW50IiwiaGFzQWNoaWV2ZW1lbnQiLCJzb21lIiwiYWN0aXZpdHlXaXRoVGltZXN0YW1wIiwiY3VycmVudEFjdGl2aXRpZXMiLCJ1cGRhdGVkQWN0aXZpdGllcyIsInNsaWNlIiwicmVjb3JkUXVpekNvbXBsZXRpb24iLCJzY29yZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/utils/userProgress.ts\n"));

/***/ })

});